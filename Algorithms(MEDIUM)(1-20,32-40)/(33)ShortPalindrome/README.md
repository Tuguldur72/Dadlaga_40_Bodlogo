# Short Palindrome

**Бодлогын холбоос:**  
https://www.hackerrank.com/challenges/short-palindrome/problem

## Бодлогын орчуулга

Танд зөвхөн жижиг үсгүүдээс бүрдэх нэг тэмдэгт мөр `s` өгөгдөнө. Та дараах хэлбэрийн палиндром хэд байгааг тоолох ёстой:

**a b b a** — 4 тэмдэгттэй палиндром бөгөөд:
- Эхний болон сүүлийн тэмдэгт адил (`a`)
- Дунд хоёр тэмдэгт адил (`b`)

Жишээлбэл, `abba` эсвэл `xzzx` зэрэг.

Танд энэ хэлбэрийн **хэдэн янзын индексийн хослол** байж болохыг тоолох хэрэгтэй. Үсгийн давхардлыг тоолно (буюу нэг үсэг олон удаа орж болно, гэхдээ янз бүрийн байрлалтай).

## Оролт

- Нэг мөр тэмдэгт мөр `s`, урт нь $1 \leq |s| \leq 10^6$

## Гаралт

- `"abba"` хэлбэртэй хэдэн өөр индексийн хослол байгааг тоолоод, `10^9 + 7`-оор хуваагаад үлдэгдлийг хэвлэнэ.

## Жишээ

**Оролт:**
abbaab

**Гаралт:**
4

**Тайлбар:**

Боломжит индексийн хослолууд:
- (0, 1, 2, 3) → `abba`
- (2, 3, 4, 5) → `baab`
- (0, 1, 4, 5) → `abba`
- (0, 1, 2, 5) → `abba`

## Шийдлийн тайлбар

Бодлогыг `O(n)`–`O(26³)` цаг хугацаанд багтаан шийдэх шаардлагатай тул brute-force (дөрвөн давталт) шийдэл болохгүй.

### Алгоритмын санаа:
- Үсгүүдийг нь баримтлах 4 төрлийн тоологч ашиглана:
  - `single[c]` → `c` үсгийн тоо
  - `pair[c1][c2]` → `c1` дараа `c2` гэсэн хоёр үсгийн дарааллын тоо
  - `triplet[c1][c2]` → `c1 c2 c2` гэсэн дарааллын тоо
  - `quad[c1][c2]` → `c1 c2 c2 c1` хэлбэрийн палиндромын тоо

### Жишээ:
`abbaab`-ийг тэмдэглэж явах явцад:
1. `a` орж ирлээ → single[a]++
2. `b` орж ирлээ → single[b]++, pair[a][b]++
3. `b` орж ирлээ → single[b]++, pair[a][b]++, triplet[a][b]++
4. `a` орж ирлээ → single[a]++, pair[b][a]++, **quad[a][b] += triplet[a][b]**

Ийнхүү дарааллаар явж `quad[a][b]`–уудын нийлбэрийг олно.

## Бодлогын шалгасан нөхцлүүд

- Хэт урт мөр дээр хурдан шийдэл ажиллах (`O(n)`-д ойролцоо)
- Давхар үсэг, давхардсан үсгийг зөв тоолсон
- Зөвхөн `"abba"` хэлбэрийн палиндром тоолсон
- Хариуг `10^9 + 7`-оор хуваасан